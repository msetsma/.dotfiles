emulate -L zsh
setopt pipefail

# Helper: Generate cache file path with hash
_gitnav_cache_path() {
  local dir="$1"
  local hash
  hash=$(echo "$dir" | md5sum | cut -d' ' -f1 2>/dev/null || echo "$dir" | md5 | cut -d' ' -f1)
  echo "${TMPDIR:-/tmp}/gitnav_cache_${USER}_${hash}.txt"
}

# Helper: Check if cache file is still valid
_gitnav_cache_valid() {
  local cache_file="$1"
  local ttl="$2"

  [[ ! -f "$cache_file" ]] && return 1

  local cache_age file_mtime current_time
  current_time=$(date +%s)
  file_mtime=$(stat -f%m "$cache_file" 2>/dev/null || stat -c%Y "$cache_file" 2>/dev/null || echo 0)
  cache_age=$((current_time - file_mtime))

  (( cache_age < ttl ))
}

local selected cache_file cache_ttl=300 current_dir force_refresh=0
current_dir="$HOME"

# Support -f flag to force refresh
if [[ "$1" == "-f" ]] || [[ "$1" == "--force" ]]; then
  force_refresh=1
fi

cache_file=$(_gitnav_cache_path "$current_dir")

# Check cache validity (5 min TTL)
local use_cache=0
if (( force_refresh == 0 )) && _gitnav_cache_valid "$cache_file" "$cache_ttl"; then
  use_cache=1
fi

local listing
if (( use_cache )); then
  listing=$(<"$cache_file")
else
  echo "running without cache"
  # Find .git directories and extract parent path efficiently with sed
  # Remove /.git/ suffix (with trailing slash from fd) to get actual repo paths
  # Format: name\trelative_path\tfull_path (sorted by name)
  local repos_raw repo_path rel_path repo_name
  repos_raw=$(fd -t d -H -I '^\.git$' "$current_dir" --max-depth 5 2>/dev/null | sed 's|/\.git/$||')

  [[ -z "$repos_raw" ]] && {
    print -P "%F{yellow}No Git repositories found in $current_dir%f"
    return 1
  }

  # Build listing efficiently with process substitution
  listing=$(
    echo "$repos_raw" | while IFS= read -r repo_path; do
      repo_name="$(basename "$repo_path")"
      rel_path="${repo_path#./}"
      [[ "$rel_path" == "$repo_path" ]] && rel_path="$repo_path" || rel_path="./$rel_path"
      printf "%s\t%s\t%s\n" "$repo_name" "$rel_path" "$repo_path"
    done | sort -t$'\t' -k1,1
  )

  # Cache the results
  echo "$listing" > "$cache_file"
fi

[[ -z "$listing" ]] && {
  print -P "%F{yellow}No Git repositories found in $current_dir%f"
  return 1
}

# FZF picker with preview
selected=$(
  echo "$listing" |
    fzf --prompt='Select repo > ' \
        --header='Repository (↑/↓, ⏎, Esc)' \
        --delimiter='\t' \
        --with-nth=1 \
        --preview='
          repo_path={3}
          cd "$repo_path" 2>/dev/null || exit 0
          echo -e "\033[1;36mRepository:\033[0m $(basename "$repo_path")"
          echo -e "\033[1;36mLocation:\033[0m $repo_path"
          echo ""
          if git rev-parse --git-dir >/dev/null 2>&1; then
            branch=$(git branch --show-current 2>/dev/null)
            [[ -n "$branch" ]] && echo -e "\033[1;33mBranch:\033[0m $branch" || echo -e "\033[1;33mBranch:\033[0m (detached HEAD)"

            # Show last commit date and time
            last_commit=$(git log -1 --format="%cr (%cd)" --date=format:"%Y-%m-%d %H:%M" 2>/dev/null)
            [[ -n "$last_commit" ]] && echo -e "\033[1;35mLast Activity:\033[0m $last_commit"

            echo ""
            echo -e "\033[1;35mStatus:\033[0m"
            git status -sb 2>/dev/null | head -10
            echo ""
            echo -e "\033[1;32mRecent commits:\033[0m"
            git log --oneline --color=always -5 2>/dev/null
          fi
        ' \
        --preview-window=right:60%:wrap \
        --layout=reverse \
        --height=90% \
        --border \
        --no-sort |
    cut -f3
)

[[ -n "$selected" ]] && {
  cd "$selected" || return
  local rel_display="${selected#$current_dir/}"
  [[ "$rel_display" == "$selected" ]] && rel_display="$selected"
  print -P "\n%F{green}✓%f Navigated to: %F{cyan}$rel_display%f"

  # Show quick git info
  if git rev-parse --git-dir >/dev/null 2>&1; then
    local branch=$(git branch --show-current 2>/dev/null)
    [[ -n "$branch" ]] && print -P "  Branch: %F{yellow}$branch%f"
  fi
}
